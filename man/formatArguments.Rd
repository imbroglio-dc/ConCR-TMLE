% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/formatArguments.R
\name{formatArguments}
\alias{formatArguments}
\title{Title}
\usage{
formatArguments(
  ConcreteArgs = NULL,
  DataTable,
  DataStructure = NULL,
  EventTime,
  EventType,
  Treatment,
  ID = NULL,
  LongTime = NULL,
  Intervention,
  TargetTime,
  TargetEvent = NULL,
  Target = NULL,
  CVArg = list(n = nrow(DataTable), fold_fun = folds_vfold, cluster_ids = NULL,
    strata_ids = NULL),
  Model = NULL,
  PropScoreBackend = "SuperLearner",
  HazEstBackend = "coxph",
  MaxUpdateIter = 100,
  OneStepEps = 0.1,
  MinNuisance = 0.05,
  Verbose = TRUE,
  GComp = TRUE,
  ReturnModels = TRUE,
  ...
)
}
\arguments{
\item{ConcreteArgs}{list (default: NULL, not yet ready) : Use to recheck amended output from previous formatArguments()
calls. A non-NULL input will cause all other arguments to be ignored.}

\item{DataTable}{data.table (n x (d + (3:5)); data.table of the observed data, with rows n =
the number of observations and d = the number of baseline covariates. DataTable must include
the following columns:
\itemize{
\item{"EventTime"}{: non-negative real numbers; the observed event or censoring time}
\item{"EventType"}{: numeric; the observed event type, with 0 indicating censoring. There is
no separate column for indicating censoring}
\item{"Treatment"}{: numeric; the observed treatment}
}
May include
\itemize{
\item{"ID"}{: factor, character, or numeric; unique subject id. If ID column is missing, row
numbers will be used as ID. For longitudinal data, ID must be provided}
\item{"LongTime"}{: numeric; Specifies monitoring times for longitudinal data structures}
\item{"Baseline Covariates"}{: factor, character, or numeric; }
}}

\item{DataStructure}{formula (not ready): e.g. Surv(time, type) ~ Intervention(trt) + ...}

\item{EventTime}{character: the column name of the observed event or censoring time}

\item{EventType}{character: the column name of the observed event type. (0 indicating censoring)}

\item{Treatment}{character: the column name of the observed treatment assignment}

\item{ID}{character (default: NULL): the column name of the observed subject id}

\item{LongTime}{character (not used): the column name of the monitoring times for
longitudinal data structures}

\item{Intervention}{list: a list of desired interventions on the treatment variable.
Each intervention must be a list containing two named functions:
'intervention' = function(treatment vector, covariate data) and
'gstar' = function(treatment vector, covariate data)
concrete:::ITT can be used to specify an intent-to-treat analysis for a
binary intervention variable}

\item{TargetTime}{numeric: vector of target times}

\item{TargetEvent}{numeric: vector of target events - some subset of unique EventTypes.}

\item{Target}{(not yet implemented) data.table / data.frame (?? x 2); a table containing all
combinations of target events (column 1) and target times (column 2).}

\item{CVArg}{list: arguments to be passed into do.call(origami::make_folds). The default is
list(n = nrow(DataTable), fold_fun = folds_vfold, cluster_ids = NULL, strata_ids = NULL)}

\item{Model}{list (default: NULL): named list of models, one for each failure or censoring event
and one for the 'Treatment' variable. If Model = NULL, then
a template will be generated for the user to amend.}

\item{PropScoreBackend}{character (default: "Superlearner"): currently must be either "sl3" or "Superlearner"}

\item{HazEstBackend}{character (default: "coxph"): currently must be "coxph"}

\item{MaxUpdateIter}{numeric: the number of one-step update steps}

\item{OneStepEps}{numeric: the one-step tmle step size}

\item{MinNuisance}{numeric: the minimum value of the nuisance parameter denominator in the
clever covariate}

\item{Verbose}{boolean}

\item{GComp}{boolean}

\item{ReturnModels}{boolean}

\item{...}{...}
}
\value{
a list of class "ConcreteArgs"
\itemize{
\item{"Data"}{: data.table containing EventTime, EventType, Treatment, and baseline covariates}
\item{"Events"}{: numeric vector encoding unique failure event types}
\item{"TargetTime"}{: numeric vector of target times to evaluate risk/survival}
\item{"TargetEvent"}{: numeric vector of target events}
\item{"Regime"}{: named list of interventions, comprised of two functions}
\itemize{
\item{"intervention"}{: function of Treatment and Covariates, outputting a vector of desired treatment assignments}
\item{"g.star"}{: function of Treatment and Covariates, outputting a vector of desired treatment assignment probabilities}
}
\item{"CVFolds"}{: list of cross-validation fold assignments in the structure as output by origami::make_folds()}
\item{"Model"}{: list of cross-validation fold assignments in the structure as output by origami::make_folds()}
\item{"PropScoreBackend"}{: list of cross-validation fold assignments in the structure as output by origami::make_folds()}
\item{"HazEstBackend"}{: list of cross-validation fold assignments in the structure as output by origami::make_folds()}
\item{"MaxUpdateIter"}{: list of cross-validation fold assignments in the structure as output by origami::make_folds()}
\item{"OneStepEps"}{: list of cross-validation fold assignments in the structure as output by origami::make_folds()}
\item{"MinNuisance"}{: numeric cutoff}
\item{"Verbose"}{: boolean}
\item{"GComp"}{: boolean, to return g-computation formula plug-in estimates or not}
}
May include
\itemize{
\item{"ID"}{: factor, character, or numeric; unique subject id. If ID column is missing, row
numbers will be used as ID. For longitudinal data, ID must be provided}
\item{"LongTime"}{: numeric; Specifies monitoring times for longitudinal data structures}
\item{"Baseline Covariates"}{: factor, character, or numeric; }
}
}
\description{
Title
}
\examples{
library(data.table)
library(concrete)

data <- as.data.table(survival::pbc)
data[, trt := sample(0:1, nrow(data), TRUE)]
cols <- c("id", "time", "status", "trt",
          "age", "albumin", "sex", "bili")
data <- data[, .SD, .SDcols = cols]
intervention <- concrete:::ITT
target.time <- 2500
target.event <- 1:2
model <- list("trt" = c("SL.glm", "SL.glmnet"),
              "0" = list(Surv(time, status == 0) ~ .),
              "1" = list(Surv(time, status == 1) ~ .),
              "2" = list(Surv(time, status == 2) ~ .))

# formatArguments() returns correctly formatted arguments for doConcrete()
concrete.args <- formatArguments(DataTable = data,
                                 EventTime = "time",
                                 EventType = "status",
                                 Treatment = "trt",
                                 ID = "id",
                                 Intervention = intervention,
                                 TargetTime = target.time,
                                 TargetEvent = target.event,
                                 Model = model)

# if formatArguments(Model = NULL), a model template will be returned for the user to amend.
# examples of editing models for censoring and failure events
concrete.args[["Model"]][["0"]] <- list("model1" = Surv(time, status == 0) ~ trt:sex + age + bili)
concrete.args[["Model"]][["1"]] <- list(Surv(time, status == 1) ~ trt, 
                                       Surv(time, status == 1) ~ .)

# examples of editing models for binary treatment, using PropScoreBackend = "Superlearner"
concrete.args[["Model"]][["trt"]] <- c("SL.glm", "SL.glmnet", "SL.bayesglm")

# examples of editing models for binary treatment, using PropScoreBackend = "sl3"
library(sl3)
concrete.args[["Model"]][["trt"]] <- make_learner(Stack, Lrnr_hal9001$new(), 
                                                 Lrnr_glmnet$new(), Lrnr_glm$new())


}
